From 7d8f0fc29fbccf6ff1b0be3bde8e7aae47725542 Mon Sep 17 00:00:00 2001
From: Poweruser <poweruser.rs@hotmail.com>
Date: Mon, 31 Aug 2015 22:12:23 +0200
Subject: [PATCH] Rewrite of Player Chunk Management


diff --git a/src/main/java/de/minetick/ChunkGenerationPolicy.java b/src/main/java/de/minetick/ChunkGenerationPolicy.java
new file mode 100644
index 0000000..66b74a4
--- /dev/null
+++ b/src/main/java/de/minetick/ChunkGenerationPolicy.java
@@ -0,0 +1,60 @@
+package de.minetick;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.bukkit.WorldType;
+
+public class ChunkGenerationPolicy {
+
+    private static HashMap<WorldType, Double> rateMap = new HashMap<WorldType, Double>();
+
+    private int generatedChunks;
+    private int ticks;
+
+    public ChunkGenerationPolicy() {
+        this.reset();
+    }
+
+    public void generatedChunk() {
+        this.generatedChunks++;
+    }
+
+    public boolean isChunkGenerationCurrentlyAllowed(WorldType type) {
+        if(this.ticks > 0) {
+            Double entry = rateMap.get(type);
+            double maxRate;
+            if(entry == null) {
+                maxRate = getDefaultRate(type);
+            } else {
+                maxRate = entry.doubleValue();
+            }
+
+            double currentRate = (double) this.generatedChunks / (double) this.ticks;
+            if(currentRate < maxRate) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void reset() {
+        this.generatedChunks = 0;
+        this.ticks = 0;
+    }
+
+    public void newTick() {
+        if(this.ticks >= 20 * 5) {
+            this.reset();
+        }
+        this.ticks++;
+    }
+
+    public static void setRatesFromConfig(Map<WorldType, Double> rates) {
+        rateMap.putAll(rates);
+    }
+
+    public static double getDefaultRate(WorldType type) {
+        return type.equals(WorldType.FLAT) ? 1.0D : 0.5D;
+    }
+}
diff --git a/src/main/java/de/minetick/Migot.java b/src/main/java/de/minetick/Migot.java
index 24a2710..3cf1645 100644
--- a/src/main/java/de/minetick/Migot.java
+++ b/src/main/java/de/minetick/Migot.java
@@ -45,6 +45,7 @@ public class Migot {
     private int ticksCounter = 0;
     private final Logger log = LogManager.getLogger();
     private PathSearchThrottlerThread pathSearchThrottler;
+    private PacketBuilderBuffer builderBuffer;
 
     public Migot() {
         this.tickTimerObject = new TickTimer();
@@ -74,6 +75,8 @@ public class Migot {
             CraftServer craftserver = MinecraftServer.getServer().server;
             craftserver.getCommandMap().register("tps", "Migot", new TPSCommand("tps"));
             craftserver.getCommandMap().register("migot-reload", "Migot", new ReloadSettingsCommand("migot-reload"));
+
+            this.builderBuffer = new PacketBuilderBuffer();
         }
     }
 
@@ -85,6 +88,10 @@ public class Migot {
         this.timerService.shutdown();
         this.nbtFileService.shutdown();
         this.pathSearchThrottler.shutdown();
+        if(this.builderBuffer != null) {
+            this.builderBuffer.clear();
+        }
+
         while(!this.nbtFileService.isTerminated()) {
             try {
                 if(!this.nbtFileService.awaitTermination(3, TimeUnit.MINUTES)) {
@@ -184,4 +191,8 @@ public class Migot {
     public static boolean queuePathSearch(PathSearchJob pathSearchJob) {
         return instance.pathSearchThrottler.queuePathSearch(pathSearchJob);
     }
+
+    public static PacketBuilderBuffer getPacketBuilderBuffer() {
+        return instance.builderBuffer;
+    }
 }
diff --git a/src/main/java/de/minetick/MigotConfig.java b/src/main/java/de/minetick/MigotConfig.java
index 5352d8f..439924c 100644
--- a/src/main/java/de/minetick/MigotConfig.java
+++ b/src/main/java/de/minetick/MigotConfig.java
@@ -4,14 +4,18 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStreamReader;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 import net.minecraft.server.EntityInsentient;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.FileConfiguration;
 import org.bukkit.configuration.file.YamlConfiguration;
@@ -19,6 +23,7 @@ import org.bukkit.entity.EntityType;
 
 import com.google.common.base.Charsets;
 
+import de.minetick.MinetickChunkCoordComparator.ChunkPriority;
 import de.minetick.pathsearch.MigotNavigation;
 import de.minetick.pathsearch.PathSearchThrottlerThread;
 
@@ -55,6 +60,8 @@ public class MigotConfig {
         this.loadEntitiesWithOffloadedPathSearches(this.getEntitiesWithOffloadedPathSearches());
         MigotNavigation.setMinimumDistanceForOffloading(this.getMinimumTargetDistanceForOffloading());
         PathSearchThrottlerThread.adjustPoolSize(this.getPathSearchPoolSize());
+        this.applyPacketChunkRates(ChunkPriority.values());
+        ChunkGenerationPolicy.setRatesFromConfig(this.getMaxChunkGenerationRates());
     }
 
     private FileConfiguration loadConfig(File file) throws IOException, InvalidConfigurationException {
@@ -103,4 +110,38 @@ public class MigotConfig {
         int threadcount = configuration.getInt("pathsearches.pathSearchThreadPoolSize", 2);
         return Math.max(1, Math.min(threadcount, 32));
     }
+
+    public void applyPacketChunkRates(ChunkPriority[] values) {
+        ConfigurationSection section = configuration.getConfigurationSection("chunkloading.packetChunkRates");
+        Set<String> subkeys = section.getKeys(false);
+        for(String key: subkeys) {
+            int chunkCount = section.getInt(key);
+            if(chunkCount >= 1 && chunkCount <= 5) {
+                ChunkPriority priority = ChunkPriority.findEntry(key);
+                if(priority != null) {
+                    priority.setChunksPerPacket(chunkCount);
+                } else {
+                    this.logger.warn("[Migot] The config entry chunkloading.packetChunkRates." + key + " is invalid. Removing it from the config.");
+                    section.set(key, null);
+                }
+            }
+        }
+    }
+
+    public Map<org.bukkit.WorldType, Double> getMaxChunkGenerationRates() {
+        ConfigurationSection section = configuration.getConfigurationSection("chunkloading.maxChunkGenerationRates");
+        Set<String> subkeys = section.getKeys(false);
+        Map<org.bukkit.WorldType, Double> rateMap = new HashMap<org.bukkit.WorldType, Double>();
+        for(String key: subkeys) {
+            org.bukkit.WorldType type = org.bukkit.WorldType.getByName(key);
+            if(type != null) {
+                double rate = section.getDouble(key, ChunkGenerationPolicy.getDefaultRate(type));
+                if(rate < 0.25D) { rate = 0.25D; }
+                rateMap.put(type, rate);
+            } else {
+                this.logger.warn("[Migot] The WorldType '" + key + "' was not recognized in the setting chunkloading.maxChunkGenerationRates");
+            }
+        }
+        return rateMap;
+    }
 }
diff --git a/src/main/java/de/minetick/MinetickChunkCoordComparator.java b/src/main/java/de/minetick/MinetickChunkCoordComparator.java
new file mode 100644
index 0000000..4aa6023
--- /dev/null
+++ b/src/main/java/de/minetick/MinetickChunkCoordComparator.java
@@ -0,0 +1,135 @@
+package de.minetick;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+import de.minetick.MinetickChunkCoordComparator.ChunkPriority;
+
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.MathHelper;
+
+public class MinetickChunkCoordComparator implements Comparator<ChunkCoordIntPair>, Serializable {
+
+    private static final long serialVersionUID = 5600078159334305946L;
+    private int x;
+    private int z;
+
+    private double[] normaldirectionVector;
+    private boolean isXnormal;
+
+    private double[] directionVector;
+    private double[] tempMatching;
+
+    public MinetickChunkCoordComparator (EntityPlayer entityplayer) {
+        this.normaldirectionVector = new double[] { 1.0D, 0.0D };
+        this.directionVector = new double[] { 1.0D, 0.0D };
+        this.tempMatching = new double[] { 1.0D, 0.0D, 1.0D }; // x component, z component, squared vector length
+        this.isXnormal = true;
+        this.setPos(entityplayer);
+    }
+
+    public void setPos(EntityPlayer entityplayer) {
+        this.x = MathHelper.floor(entityplayer.locX) >> 4;
+        this.z = MathHelper.floor(entityplayer.locZ) >> 4;
+        this.calcDirectionVectors(entityplayer.yaw);
+        this.x -= (this.normaldirectionVector[0] * 1.5D);
+        this.z -= (this.normaldirectionVector[1] * 1.5D);
+    }
+
+    @Override
+    public int compare(ChunkCoordIntPair a, ChunkCoordIntPair b) {
+        double weightA = this.calcChunkWeight(a);
+        double weightB = this.calcChunkWeight(b);
+
+        if(weightA < weightB) {
+            return -1;
+        } else if(weightA > weightB) {
+            return 1;
+        } else {
+            return (a.x + a.z) - (b.x + b.z);
+        }
+    }
+
+    private void calcDirectionVectors(float yaw) {
+        this.directionVector[0] = Math.sin(Math.toRadians(yaw + 180.0f));
+        this.directionVector[1] = Math.cos(Math.toRadians(yaw));
+        double max;
+        double absX = Math.abs(this.directionVector[0]);
+        double absZ = Math.abs(this.directionVector[1]);
+        if(absX > absZ) {
+            this.isXnormal = true;
+            max = absX;
+        } else {
+            this.isXnormal = false;
+            max = absZ;
+        }
+        double factor = 1.0D / max;
+        this.normaldirectionVector[0] = this.directionVector[0] * factor;
+        this.normaldirectionVector[1] = this.directionVector[1] * factor;
+    }
+
+    private double[] getMatchingDirectionVector(ChunkCoordIntPair ccip) {
+        int abs = Math.abs(this.isXnormal ? ccip.x - this.x : ccip.z - this.z);
+        this.tempMatching[0] = this.normaldirectionVector[0] * abs;
+        this.tempMatching[1] = this.normaldirectionVector[1] * abs;
+        this.tempMatching[2] = (this.tempMatching[0] * this.tempMatching[0]) + (this.tempMatching[1] * this.tempMatching[1]);
+        return this.tempMatching;
+    }
+
+    private double calcDistance(ChunkCoordIntPair ccip, double[] matchingVector) {
+        double diffX = ccip.x - (this.x + matchingVector[0]);
+        double diffZ = ccip.z - (this.z + matchingVector[1]);
+        return diffX * diffX + diffZ * diffZ;
+    }
+
+    public enum ChunkPriority {
+        HIGHEST(5),
+        HIGH(3),
+        MODERATE(2),
+        LOW(1);
+
+        private int chunksPerPacket;
+
+        private ChunkPriority(int chunksPerPacket) {
+            this.chunksPerPacket = chunksPerPacket;
+        }
+
+        public void setChunksPerPacket(int count) {
+            this.chunksPerPacket = count;
+        }
+
+        public int getChunksPerPacket() {
+            return this.chunksPerPacket;
+        }
+
+        public static ChunkPriority findEntry(String key) {
+            try {
+                ChunkPriority pri = valueOf(key);
+                return pri;
+            } catch (IllegalArgumentException e) {
+                return null;
+            } catch (NullPointerException e) {
+                return null;
+            }
+        }
+    }
+
+    private double calcChunkWeight(ChunkCoordIntPair ccip) {
+        double[] matchingVector = this.getMatchingDirectionVector(ccip);
+        return (matchingVector[2] * 0.06D) + this.calcDistance(ccip, matchingVector);
+    }
+
+    public ChunkPriority getChunkPriority(ChunkCoordIntPair ccip) {
+        double chunkWeight = this.calcChunkWeight(ccip);
+        if(chunkWeight < 4.0D) {
+            return ChunkPriority.HIGHEST;
+        } else if(chunkWeight < 40.0D) {
+            return ChunkPriority.HIGH;
+        } else if(chunkWeight < 100.0D) {
+            return ChunkPriority.MODERATE;
+        } else {
+            return ChunkPriority.LOW;
+        }
+    }
+}
diff --git a/src/main/java/de/minetick/PacketBuilderBuffer.java b/src/main/java/de/minetick/PacketBuilderBuffer.java
new file mode 100644
index 0000000..d4014bd
--- /dev/null
+++ b/src/main/java/de/minetick/PacketBuilderBuffer.java
@@ -0,0 +1,46 @@
+package de.minetick;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+public class PacketBuilderBuffer {
+
+    private ArrayList<WeakReference<byte[]>> sendBufferCache = new ArrayList<WeakReference<byte[]>>();
+
+    public PacketBuilderBuffer() {}
+
+    public void offerSendBuffer(byte[] array) {
+        synchronized(this.sendBufferCache) {
+            this.sendBufferCache.add(new WeakReference<byte[]>(array));
+        }
+    }
+
+    public byte[] requestSendBuffer(int length) {
+        synchronized(this.sendBufferCache) {
+            return this.checkInList(this.sendBufferCache, length);
+        }
+    }
+
+    public void clear() {
+        synchronized(this.sendBufferCache) {
+            this.sendBufferCache.clear();
+        }
+    }
+
+    private byte[] checkInList(ArrayList<WeakReference<byte[]>> list, int length) {
+        WeakReference<byte[]> ref;
+        byte[] array;
+        int size = list.size();
+        for(int i = size - 1; i >= 0; i--) {
+            ref = list.get(i);
+            array = ref.get();
+            if(array == null) {
+                list.remove(i);
+            } else if(array.length == length) {
+                list.remove(i);
+                return array;
+            }
+        }
+        return new byte[length];
+    }
+}
diff --git a/src/main/java/de/minetick/PlayerChunkBuffer.java b/src/main/java/de/minetick/PlayerChunkBuffer.java
new file mode 100644
index 0000000..cf5191c
--- /dev/null
+++ b/src/main/java/de/minetick/PlayerChunkBuffer.java
@@ -0,0 +1,169 @@
+package de.minetick;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.PriorityQueue;
+
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.PlayerChunkMap;
+import net.minecraft.server.PlayerChunkMap.PlayerChunk;
+
+public class PlayerChunkBuffer {
+    private LinkedHashSet<ChunkCoordIntPair> lowPriorityBuffer;
+    private LinkedHashSet<ChunkCoordIntPair> highPriorityBuffer;
+    public PriorityQueue<ChunkCoordIntPair> pq;
+    public MinetickChunkCoordComparator comp;
+    public int generatedChunks = 0;
+    public int loadedChunks = 0;
+    public int skippedChunks = 0;
+    public int enlistedChunks = 0;
+    private PlayerChunkManager playerChunkManager;
+    private PlayerChunkSendQueue sendQueue;
+    private int[] playerRegionCenter;
+    private int[] lastMovement;
+    private ArrayDeque<PlayerMovement> movement;
+
+    public PlayerChunkBuffer(PlayerChunkManager playerChunkManager, EntityPlayer ent) {
+        this.playerChunkManager = playerChunkManager;
+        this.lowPriorityBuffer = new LinkedHashSet<ChunkCoordIntPair>();
+        this.highPriorityBuffer = new LinkedHashSet<ChunkCoordIntPair>();
+        this.sendQueue = new PlayerChunkSendQueue(this.playerChunkManager, ent);
+        this.comp = new MinetickChunkCoordComparator(ent);
+        this.pq = new PriorityQueue<ChunkCoordIntPair>(750, this.comp);
+        this.playerRegionCenter = new int[] { MathHelper.floor(ent.locX) >> 4, MathHelper.floor(ent.locZ) >> 4 };
+        this.lastMovement = new int[] { 0, 0 };
+        this.movement = new ArrayDeque<PlayerMovement>();
+    }
+
+    public PlayerChunkSendQueue getPlayerChunkSendQueue() {
+        return this.sendQueue;
+    }
+
+    public Comparator<ChunkCoordIntPair> updatePos(EntityPlayer entityplayer) {
+        this.comp.setPos(entityplayer);
+        if(!this.movement.isEmpty()) {
+            PlayerChunkMap pcm = this.playerChunkManager.getPlayerChunkMap();
+            PlayerMovement movement = this.movement.poll();
+            while(!this.movement.isEmpty()) {
+                movement.addMovement(this.movement.poll(), true);
+            }
+            int newCenterX = movement.getCenterX();
+            int newCenterZ = movement.getCenterZ();
+            int diffX = movement.getMovementX();
+            int diffZ = movement.getMovementZ();
+            int oldCenterX = newCenterX - diffX;
+            int oldCenterZ = newCenterZ - diffZ;
+
+            if(diffX == 0 && diffZ == 0) {
+                return this.comp;
+            }
+            int radius = pcm.getViewDistance();
+            int added = 0, removed = 0;
+            boolean areaExists = this.playerChunkManager.doAllCornersOfPlayerAreaExist(newCenterX, newCenterZ, radius);
+            for (int pointerX = newCenterX - radius; pointerX <= newCenterX + radius; pointerX++) {
+                for (int pointerZ = newCenterZ - radius; pointerZ <= newCenterZ + radius; pointerZ++) {
+                    ChunkCoordIntPair ccip;
+                    if(!PlayerChunkManager.isWithinRadius(pointerX, pointerZ, oldCenterX, oldCenterZ, radius)) {
+                        ccip = new ChunkCoordIntPair(pointerX, pointerZ);
+                        if(!this.sendQueue.alreadyLoaded(ccip) && !this.sendQueue.isOnServer(ccip)) {
+                            added++;
+                            this.sendQueue.addToServer(pointerX, pointerZ);
+                            if(areaExists) {
+                                this.addHighPriorityChunk(ccip);
+                            } else {
+                                this.addLowPriorityChunk(ccip);
+                            }
+                        }
+                    }
+
+                    if(!PlayerChunkManager.isWithinRadius(pointerX - diffX, pointerZ - diffZ, newCenterX, newCenterZ, radius)) {
+                        removed++;
+                        ccip = new ChunkCoordIntPair(pointerX - diffX, pointerZ - diffZ);
+                        this.sendQueue.removeFromServer(ccip.x, ccip.z);
+                        this.sendQueue.removeFromClient(ccip);
+                        this.remove(ccip);
+                        PlayerChunkMap.PlayerChunk playerchunk = pcm.a(ccip.x, ccip.z, false);
+                        if (playerchunk != null) {
+                            playerchunk.b(entityplayer);
+                        }
+                    }
+                }
+            }
+        }
+        return this.comp;
+    }
+
+    public void clear() {
+        this.lowPriorityBuffer.clear();
+        this.highPriorityBuffer.clear();
+        this.pq.clear();
+        this.sendQueue.clear();
+        this.movement.clear();
+    }
+
+    public boolean isEmpty() {
+        return this.lowPriorityBuffer.isEmpty() && this.highPriorityBuffer.isEmpty();
+    }
+
+    public LinkedHashSet<ChunkCoordIntPair> getLowPriorityBuffer() {
+        return this.lowPriorityBuffer;
+    }
+
+    public LinkedHashSet<ChunkCoordIntPair> getHighPriorityBuffer() {
+        return this.highPriorityBuffer;
+    }
+
+    public void addLowPriorityChunk(ChunkCoordIntPair ccip) {
+        this.lowPriorityBuffer.add(ccip);
+    }
+
+    public void addHighPriorityChunk(ChunkCoordIntPair ccip) {
+        this.highPriorityBuffer.add(ccip);
+    }
+
+    public void remove(ChunkCoordIntPair ccip) {
+        this.lowPriorityBuffer.remove(ccip);
+        this.highPriorityBuffer.remove(ccip);
+    }
+
+    public boolean contains(ChunkCoordIntPair ccip) {
+        return this.lowPriorityBuffer.contains(ccip) || this.highPriorityBuffer.contains(ccip);
+    }
+
+    public PriorityQueue<ChunkCoordIntPair> getLowPriorityQueue() {
+        this.pq.clear();
+        this.pq.addAll(this.lowPriorityBuffer);
+        return this.pq;
+    }
+
+    public PriorityQueue<ChunkCoordIntPair> getHighPriorityQueue() {
+        this.pq.clear();
+        this.pq.addAll(this.highPriorityBuffer);
+        return this.pq;
+    }
+
+    public void resetCounters() {
+        this.generatedChunks = 0;
+        this.enlistedChunks = 0;
+        this.skippedChunks = 0;
+        this.loadedChunks = 0;
+    }
+
+    public void playerMoved(int newCenterX, int newCenterZ) {
+        this.lastMovement[0] = newCenterX - this.playerRegionCenter[0];
+        this.lastMovement[1] = newCenterZ - this.playerRegionCenter[1];
+        this.playerRegionCenter[0] = newCenterX;
+        this.playerRegionCenter[1] = newCenterZ;
+        this.movement.add(new PlayerMovement(this.playerRegionCenter, this.lastMovement));
+    }
+
+    public int[] getPlayerRegionCenter() {
+        return this.playerRegionCenter;
+    }
+}
diff --git a/src/main/java/de/minetick/PlayerChunkManager.java b/src/main/java/de/minetick/PlayerChunkManager.java
new file mode 100644
index 0000000..4e52d87
--- /dev/null
+++ b/src/main/java/de/minetick/PlayerChunkManager.java
@@ -0,0 +1,225 @@
+package de.minetick;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.PriorityQueue;
+
+import de.minetick.MinetickChunkCoordComparator.ChunkPriority;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.PacketPlayOutMapChunkBulk;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.PlayerChunkMap;
+import net.minecraft.server.PlayerChunkMap.PlayerChunk;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.WorldData;
+import net.minecraft.server.WorldServer;
+import net.minecraft.server.WorldType;
+
+public class PlayerChunkManager {
+
+    private List<EntityPlayer> shuffleList = Collections.synchronizedList(new LinkedList<EntityPlayer>());
+    private boolean skipHeavyCalculations = false;
+    private int chunkCreated = 0;
+    private WorldServer world;
+    private PlayerChunkMap pcm;
+
+    private Map<String, PlayerChunkBuffer> playerBuff = new HashMap<String, PlayerChunkBuffer>();
+
+    public PlayerChunkManager(WorldServer world, PlayerChunkMap pcm) {
+        this.world = world;
+        this.pcm = pcm;
+    }
+
+    public PlayerChunkMap getPlayerChunkMap() {
+        return this.pcm;
+    }
+
+    private String getMapKey(EntityPlayer entity) {
+        return entity.getBukkitEntity().getName();
+    }
+
+    public PlayerChunkBuffer getChunkBuffer(EntityPlayer entityplayer) {
+        return this.playerBuff.get(this.getMapKey(entityplayer));
+    }
+
+    public PlayerChunkBuffer addPlayer(EntityPlayer entityplayer) {
+        String mapkey = this.getMapKey(entityplayer);
+        PlayerChunkBuffer buff = this.playerBuff.get(mapkey);
+        if(buff == null) {
+            buff = new PlayerChunkBuffer(this, entityplayer);
+            synchronized(this.playerBuff) {
+                this.playerBuff.put(mapkey, buff);
+            }
+        } else {
+            buff.clear();
+        }
+        this.shuffleList.add(entityplayer);
+        return buff;
+    }
+
+    public void removePlayer(EntityPlayer entityplayer) {
+        this.shuffleList.remove(entityplayer);
+        String mapkey = this.getMapKey(entityplayer);
+        PlayerChunkBuffer buff = this.playerBuff.get(mapkey);
+        if(buff != null) {
+            buff.clear();
+        }
+        synchronized(this.playerBuff) {
+            this.playerBuff.remove(mapkey);
+        }
+    }
+
+    public boolean skipChunkGeneration() {
+        return this.skipHeavyCalculations;
+    }
+
+    public void skipChunkGeneration(boolean skip) {
+        this.skipHeavyCalculations = skip;
+    }
+
+    public boolean alreadyEnqueued(EntityPlayer entityplayer, ChunkCoordIntPair ccip) {
+        PlayerChunkBuffer buff = this.playerBuff.get(this.getMapKey(entityplayer));
+        if(buff == null) {
+            return false;
+        }
+        if(buff.contains(ccip)) {
+            return true;
+        }
+        return false;
+    }
+
+    public int updatePlayers(ChunkGenerationPolicy chunkGenerationPolicy) {
+        int allGenerated = 0;
+        EntityPlayer[] array = this.shuffleList.toArray(new EntityPlayer[0]);
+        for(int i = 0; i < array.length; i++) {
+            EntityPlayer entityplayer = array[i];
+            PlayerChunkBuffer buff = this.playerBuff.get(this.getMapKey(entityplayer));
+            if(buff == null) {
+                continue;
+            }
+            buff.resetCounters();
+            buff.updatePos(entityplayer);
+            int playerChunkPosX = buff.getPlayerRegionCenter()[0];
+            int playerChunkPosZ = buff.getPlayerRegionCenter()[1];
+
+            // High priority chunks
+            PriorityQueue<ChunkCoordIntPair> queue = buff.getHighPriorityQueue();
+            while(queue.size() > 0 && buff.loadedChunks < (this.skipHeavyCalculations ? 5: 15)) {
+                ChunkCoordIntPair ccip = queue.poll();
+                if(buff.getPlayerChunkSendQueue().isOnServer(ccip) && !buff.getPlayerChunkSendQueue().alreadyLoaded(ccip)) {
+                    PlayerChunkMap.PlayerChunk c = this.pcm.a(ccip.x, ccip.z, true);
+                    c.a(entityplayer);
+                    if(buff.getPlayerChunkSendQueue().queueForSend(c, entityplayer)) {
+                        buff.loadedChunks++;
+                    }
+                }
+                buff.remove(ccip);
+            }
+
+            // Low priority chunks
+            queue = buff.getLowPriorityQueue();
+            while(queue.size() > 0 && buff.loadedChunks < 5 && !this.skipHeavyCalculations) {
+                ChunkCoordIntPair ccip = queue.poll();
+                if(buff.getPlayerChunkSendQueue().isOnServer(ccip) && !buff.getPlayerChunkSendQueue().alreadyLoaded(ccip)) {
+                    boolean chunkExists = this.world.chunkProviderServer.doesChunkExist(ccip.x, ccip.z);
+                    if(!this.skipHeavyCalculations && (chunkExists || chunkGenerationPolicy.isChunkGenerationCurrentlyAllowed(this.world.getWorld().getWorldType()))) {
+                        PlayerChunkMap.PlayerChunk c = this.pcm.a(ccip.x, ccip.z, true);
+                        c.a(entityplayer);
+                        if(c.getAndResetIsNew()) {
+                            buff.generatedChunks++;
+                            allGenerated++;
+                            chunkGenerationPolicy.generatedChunk();
+                        } else {
+                            buff.loadedChunks++;
+                        }
+                        buff.getPlayerChunkSendQueue().queueForSend(c, entityplayer);
+                        buff.remove(ccip);
+                    } else {
+                        buff.skippedChunks++;
+                    }
+                } else {
+                    buff.remove(ccip);
+                }
+            }
+            PlayerChunkSendQueue chunkQueue = buff.getPlayerChunkSendQueue();
+            int previouslyskipped = chunkQueue.requeuePreviouslySkipped();
+            if(buff.generatedChunks > 0 || buff.loadedChunks > 0 || buff.enlistedChunks > 0 || previouslyskipped > 0) {
+                chunkQueue.sort(entityplayer);
+            }
+            if(buff.generatedChunks > 0) {
+                this.shuffleList.remove(entityplayer);
+                this.shuffleList.add(entityplayer);
+            }
+            if(!chunkQueue.hasChunksQueued()) { return allGenerated; }
+            int skipped = 0;
+            ArrayList<Chunk> list = new ArrayList<Chunk>();
+            ArrayList<TileEntity> tileEntityList = new ArrayList<TileEntity>();
+            while(chunkQueue.hasChunksQueued() && list.size() < this.world.spigotConfig.maxBulkChunk && skipped < (20 + previouslyskipped)) {
+                ChunkCoordIntPair chunkcoordintpair = chunkQueue.peekFirst();
+                if (chunkcoordintpair != null && chunkQueue.isOnServer(chunkcoordintpair)) {
+                    if(this.world.chunkProviderServer.isChunkLoaded(chunkcoordintpair.x, chunkcoordintpair.z)) {
+                        Chunk chunk = this.world.getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z);
+                        if(chunk.isReady()) {
+                            list.add(chunk);
+                            tileEntityList.addAll(chunk.tileEntities.values());
+                            chunkQueue.removeFirst(true);
+                            ChunkPriority priority = buff.comp.getChunkPriority(chunkcoordintpair);
+                            if(list.size() >= priority.getChunksPerPacket()) {
+                                break;
+                            }
+                        } else {
+                            chunkQueue.skipFirst();
+                            skipped++;
+                        }
+                    } else {
+                        chunkQueue.skipFirst();
+                        skipped++;
+                    }
+                } else {
+                    chunkQueue.removeFirst(false);
+                }
+            }
+            if (!list.isEmpty()) {
+                if(list.size() == 1) {
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(Migot.getPacketBuilderBuffer(), (Chunk) list.get(0), true, '\uffff'));
+                } else {
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(Migot.getPacketBuilderBuffer(), list));                    
+                }
+
+                Iterator<TileEntity> tilesIterator = tileEntityList.iterator();
+
+                while (tilesIterator.hasNext()) {
+                    TileEntity tileentity = tilesIterator.next();
+
+                    entityplayer.a(tileentity);
+                }
+
+                entityplayer.queueChunksForTracking(list);
+            }
+        }
+        return allGenerated;
+    }
+
+    public static boolean isWithinRadius(int positionx, int positionz, int centerx, int centerz, int radius) {
+        int distancex = positionx - centerx;
+        int distancez = positionz - centerz;
+
+        return (distancex >= -radius && distancex <= radius) ? (distancez >= -radius && distancez <= radius) : false;
+    }
+
+    public boolean doAllCornersOfPlayerAreaExist(int x, int z, int radius) {
+        boolean exists = this.world.chunkExists(x - radius, z - radius);
+        exists = exists && this.world.chunkExists(x + radius, z + radius);
+        if(!exists) { return false; }
+        exists = exists && this.world.chunkExists(x - radius, z + radius);
+        return exists && this.world.chunkExists(x + radius, z - radius);
+    }
+}
diff --git a/src/main/java/de/minetick/PlayerChunkSendQueue.java b/src/main/java/de/minetick/PlayerChunkSendQueue.java
new file mode 100644
index 0000000..ea3af3f
--- /dev/null
+++ b/src/main/java/de/minetick/PlayerChunkSendQueue.java
@@ -0,0 +1,165 @@
+package de.minetick;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+
+import org.bukkit.craftbukkit.util.LongHash;
+
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.PlayerChunkMap;
+import net.minecraft.server.PlayerChunkMap.PlayerChunk;
+
+public class PlayerChunkSendQueue {
+
+    private LinkedHashSet<Long> serverData; // what it should be
+    private LinkedHashSet<Long> clientData; // sent Data
+    private LinkedList<ChunkCoordIntPair> queue; // waiting to be sent
+    private LinkedList<ChunkCoordIntPair> skippedChunks;
+    private PlayerChunkManager pcm;
+    private EntityPlayer player;
+
+    public PlayerChunkSendQueue(PlayerChunkManager pcm, EntityPlayer entityplayer) {
+        this.pcm = pcm;
+        this.serverData = new LinkedHashSet<Long>();
+        this.clientData = new LinkedHashSet<Long>();
+        this.queue = new LinkedList<ChunkCoordIntPair>();
+        this.skippedChunks = new LinkedList<ChunkCoordIntPair>();
+        this.player = entityplayer;
+    }
+
+    public void sort(EntityPlayer entityplayer) {
+        MinetickChunkCoordComparator comp = new MinetickChunkCoordComparator(entityplayer);
+        Collections.sort(this.queue, comp);
+        Collections.sort(this.player.chunkCoordIntPairQueue, comp);
+    }
+
+    public boolean hasChunksQueued() {
+        return this.queue.size() > 0;
+    }
+
+    public boolean queueForSend(PlayerChunkMap.PlayerChunk playerchunk, EntityPlayer entityplayer) {
+        boolean alreadySent = false, onServer = false, aboutToSend = false;
+        ChunkCoordIntPair ccip = playerchunk.getLocation();
+        alreadySent = this.clientData.contains(LongHash.toLong(ccip.x, ccip.z));
+        onServer = this.serverData.contains(LongHash.toLong(ccip.x, ccip.z));
+        aboutToSend = this.isAboutToSend(ccip);
+        if(onServer) {
+            if(!aboutToSend && !alreadySent) {
+                this.queue.add(ccip);
+                this.player.chunkCoordIntPairQueue.add(ccip);
+                return true;
+            }
+        } else {
+            playerchunk.b(entityplayer);
+            this.removeFromClient(ccip);
+        }
+        return false;
+    }
+
+    public void addToServer(int x, int z) {
+        this.serverData.add(LongHash.toLong(x, z));
+    }
+
+    public void removeFromServer(int x, int z) {
+        this.serverData.remove(LongHash.toLong(x, z));
+    }
+
+    public void removeFromClient(ChunkCoordIntPair ccip) {
+        this.clientData.remove(LongHash.toLong(ccip.x, ccip.z));
+        this.removeFromQueue(ccip);
+    }
+
+    public void removeFromQueue(ChunkCoordIntPair ccip) {
+        this.queue.remove(ccip);
+        this.skippedChunks.remove(ccip);
+        this.player.chunkCoordIntPairQueue.remove(ccip);
+    }
+
+    public ChunkCoordIntPair peekFirst() {
+        ChunkCoordIntPair ccip = null;
+        boolean foundOne = false;
+        while(!foundOne && !this.queue.isEmpty()) {
+            ccip = this.queue.peekFirst();
+            if(!this.isOnServer(ccip)) {
+                this.removeFromQueue(ccip);
+                ccip = null;
+            } else {
+                foundOne = true;
+            }
+        }
+        return ccip;
+    }
+
+    public void removeFirst(boolean ok) {
+        if(!this.queue.isEmpty()) {
+            ChunkCoordIntPair ccip = this.queue.removeFirst();
+            if(ok && ccip != null) {
+                this.clientData.add(LongHash.toLong(ccip.x, ccip.z));
+                this.player.chunkCoordIntPairQueue.remove(ccip);
+            }
+        }
+    }
+
+    public void skipFirst() {
+        if(!this.queue.isEmpty()) {
+            ChunkCoordIntPair ccip = this.queue.removeFirst();
+            this.player.chunkCoordIntPairQueue.remove(ccip);
+            if(ccip != null && this.isOnServer(ccip) && !this.isChunkSent(ccip)) {
+                 this.skippedChunks.addLast(ccip);
+            }
+        }
+    }
+
+    public int requeuePreviouslySkipped() {
+        int count = 0;
+        while(this.skippedChunks.size() > 0) {
+            ChunkCoordIntPair ccip = this.skippedChunks.removeFirst();
+            if(ccip != null && this.isOnServer(ccip) && !this.alreadyLoaded(ccip)) {
+                count++;
+                this.queue.addFirst(ccip);
+                this.player.chunkCoordIntPairQueue.add(ccip);
+            }
+        }
+        return count;
+    }
+
+    public void clear() {
+        this.serverData.clear();
+        this.clientData.clear();
+        this.queue.clear();
+        this.skippedChunks.clear();
+        this.player.chunkCoordIntPairQueue.clear();
+    }
+
+    public boolean isChunkSent(ChunkCoordIntPair ccip) {
+        return this.clientData.contains(LongHash.toLong(ccip.x, ccip.z));
+    }
+
+    public boolean isAboutToSend(ChunkCoordIntPair location) {
+        return this.skippedChunks.contains(location) || this.queue.contains(location);
+    }
+
+    public boolean alreadyLoaded(ChunkCoordIntPair ccip) {
+        return this.isChunkSent(ccip) || this.isAboutToSend(ccip);
+    }
+
+    public boolean isOnServer(ChunkCoordIntPair ccip) {
+        return this.isOnServer(ccip.x, ccip.z);
+    }
+
+    public boolean isOnServer(int x, int z) {
+        return this.serverData.contains(LongHash.toLong(x, z));
+    }
+
+    public int size() {
+        return this.queue.size();
+    }
+
+    public Collection<Long> getEnlistedChunkHashes() {
+        return this.serverData;
+    }
+}
diff --git a/src/main/java/de/minetick/PlayerMovement.java b/src/main/java/de/minetick/PlayerMovement.java
new file mode 100644
index 0000000..abe6962
--- /dev/null
+++ b/src/main/java/de/minetick/PlayerMovement.java
@@ -0,0 +1,48 @@
+package de.minetick;
+
+public class PlayerMovement {
+
+    private int centerX;
+    private int centerZ;
+    private int movementX;
+    private int movementZ;
+
+    public PlayerMovement(int centerX, int centerZ, int movementX, int movementZ) {
+        this.centerX = centerX;
+        this.centerZ = centerZ;
+        this.movementX = movementX;
+        this.movementZ = movementZ;
+    }
+
+    public PlayerMovement(int[] center, int[] movement) {
+        this.centerX = center[0];
+        this.centerZ = center[1];
+        this.movementX = movement[0];
+        this.movementZ = movement[1];
+    }
+
+    public void addMovement(PlayerMovement previousmovement, boolean updateCenter) {
+        this.movementX += previousmovement.getMovementX();
+        this.movementZ += previousmovement.getMovementZ();
+        if(updateCenter) {
+            this.centerX = previousmovement.getCenterX();
+            this.centerZ = previousmovement.getCenterZ();
+        }
+    }
+
+    public int getMovementX() {
+        return this.movementX;
+    }
+
+    public int getMovementZ() {
+        return this.movementZ;
+    }
+
+    public int getCenterX() {
+        return this.centerX;
+    }
+
+    public int getCenterZ() {
+        return this.centerZ;
+    }
+}
diff --git a/src/main/java/de/minetick/SendBufferPacketBase.java b/src/main/java/de/minetick/SendBufferPacketBase.java
new file mode 100644
index 0000000..adb0c15
--- /dev/null
+++ b/src/main/java/de/minetick/SendBufferPacketBase.java
@@ -0,0 +1,40 @@
+package de.minetick;
+
+import net.minecraft.server.PacketPlayOutMapChunk.ChunkMap;
+
+public abstract class SendBufferPacketBase {
+
+    protected PacketBuilderBuffer pbb;
+    private int useCount;
+
+    protected SendBufferPacketBase() {
+        this(null);
+    }
+
+    protected SendBufferPacketBase(PacketBuilderBuffer pbb) {
+        this.pbb = pbb;
+        this.useCount = 1;
+    }
+
+    public void setUseCount(int count) {
+        this.useCount = count;
+    }
+
+    protected int decreaseAndGetUseCount() {
+        return --this.useCount;
+    }
+
+    protected void freeSendBuffer(ChunkMap[] maps) {
+        for(ChunkMap map: maps) {
+            this.freeSendBuffer(map);
+        }
+    }
+
+    protected void freeSendBuffer(ChunkMap map) {
+        if(this.pbb != null && map.a != null) {
+            this.pbb.offerSendBuffer(map.a);
+            map.a = null;
+            this.pbb = null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 95e8d16..3ab3c86 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -46,6 +46,7 @@ public class Chunk {
 
     // Migot start
     private boolean unloaded = false;
+    private boolean newChunk = false;
 
     public boolean wasUnloaded() {
         return this.unloaded;
@@ -54,6 +55,16 @@ public class Chunk {
     public void markAsUnloaded() {
         this.unloaded = true;
     }
+
+    public void markAsNew() {
+        this.newChunk = true;
+    }
+
+    public boolean getAndResetIsNew() {
+        boolean out = this.newChunk;
+        this.newChunk = false;
+        return out;
+    }
     // Migot end
 
     // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index ccfd8c2..5db590c 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -165,6 +165,7 @@ public class ChunkProviderServer implements IChunkProvider {
                     }
                 }
                 newChunk = true; // CraftBukkit
+                chunk.markAsNew(); // Migot
             }
 
             this.chunks.put(LongHash.toLong(i, j), chunk);
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 3810f86..5776f85 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -24,6 +24,11 @@ import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 // CraftBukkit end
 
+// Migot start
+import de.minetick.PlayerChunkSendQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+// Migot end
+
 public class EntityPlayer extends EntityHuman implements ICrafting {
 
     private static final Logger bH = LogManager.getLogger();
@@ -78,6 +83,22 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
     // Spigot end
 
+    // Migot start
+    public PlayerChunkSendQueue chunkQueue;
+    private ConcurrentLinkedQueue<Chunk> chunksForTracking = new ConcurrentLinkedQueue<Chunk>();
+
+    public void setPlayerChunkSendQueue(PlayerChunkSendQueue pcsq) {
+        if(this.chunkQueue != null) {
+            this.chunkQueue.clear();
+        }
+        this.chunkQueue = pcsq;
+    }
+
+    public void queueChunksForTracking(List<Chunk> list) {
+        this.chunksForTracking.addAll(list);
+    }
+    // Migot end
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super(worldserver, gameprofile);
         playerinteractmanager.player = this;
@@ -216,6 +237,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
         }
 
+        /* Migot - The PlayerChunkManager is going to handle this
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
             ArrayList arraylist = Lists.newArrayList();
             Iterator iterator1 = this.chunkCoordIntPairQueue.iterator();
@@ -263,6 +285,14 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
                 }
             }
         }
+        */
+
+        // Migot start
+        while(!this.chunksForTracking.isEmpty()) {
+            Chunk c = this.chunksForTracking.poll();
+            this.u().getTracker().a(this, c);
+        }
+        // Migot end
 
         Entity entity = this.C();
 
@@ -546,7 +576,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         return entityplayer.isSpectator() ? this.C() == this : (this.isSpectator() ? false : super.a(entityplayer));
     }
 
-    private void a(TileEntity tileentity) {
+    public void a(TileEntity tileentity) { // Migot - public
         if (tileentity != null) {
             Packet packet = tileentity.getUpdatePacket();
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 2826b6a..87de286 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -870,6 +870,12 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
         }
 
+        // Migot start
+        for(i = 0; i < this.worlds.size(); i++) {
+            this.worlds.get(i).loadAndGenerateChunks();
+        }
+        // Migot end
+
         this.migot.cancelTimerTask(false); // Migot
 
         this.methodProfiler.c("connection");
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index 58c0275..5707f45 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -1,11 +1,17 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 
-public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
+// Migot start
+import de.minetick.PacketBuilderBuffer;
+import de.minetick.SendBufferPacketBase;
+// Migot end
+
+public class PacketPlayOutMapChunk extends SendBufferPacketBase implements Packet<PacketListenerPlayOut> { // Migot
 
     private int a;
     private int b;
@@ -14,11 +20,18 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
     public PacketPlayOutMapChunk() {}
 
+    // Migot start
     public PacketPlayOutMapChunk(Chunk chunk, boolean flag, int i) {
+        this(null, chunk, flag, i);
+    }
+
+    public PacketPlayOutMapChunk(PacketBuilderBuffer pbb, Chunk chunk, boolean flag, int i) {
+        super(pbb);
+    // Migot end
         this.a = chunk.locX;
         this.b = chunk.locZ;
         this.d = flag;
-        this.c = a(chunk, flag, !chunk.getWorld().worldProvider.o(), i);
+        this.c = a(pbb, chunk, flag, !chunk.getWorld().worldProvider.o(), i); // Migot
         chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(chunk.locX, chunk.locZ, c.b, c.a, chunk.world);
     }
 
@@ -37,6 +50,12 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
         packetdataserializer.writeBoolean(this.d);
         packetdataserializer.writeShort((short) (this.c.b & '\uffff'));
         packetdataserializer.a(this.c.a);
+
+        // Migot start
+        if(this.decreaseAndGetUseCount() == 0) {
+            this.freeSendBuffer(this.c);
+        }
+        // Migot end
     }
 
     public void a(PacketListenerPlayOut packetlistenerplayout) {
@@ -52,7 +71,13 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
         return j + k + l + i1;
     }
 
+    // Migot start
     public static PacketPlayOutMapChunk.ChunkMap a(Chunk chunk, boolean flag, boolean flag1, int i) {
+        return a(null, chunk, flag, flag1, i);
+    }
+
+    public static PacketPlayOutMapChunk.ChunkMap a(PacketBuilderBuffer pbb, Chunk chunk, boolean flag, boolean flag1, int i) {
+    // Migot end
         ChunkSection[] achunksection = chunk.getSections();
         PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = new PacketPlayOutMapChunk.ChunkMap();
         ArrayList arraylist = Lists.newArrayList();
@@ -68,7 +93,14 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
             }
         }
 
-        packetplayoutmapchunk_chunkmap.a = new byte[a(Integer.bitCount(packetplayoutmapchunk_chunkmap.b), flag1, flag)];
+        // Migot start
+        int length = a(Integer.bitCount(packetplayoutmapchunk_chunkmap.b), flag1, flag);
+        if(pbb != null) {
+            packetplayoutmapchunk_chunkmap.a = pbb.requestSendBuffer(length);
+        } else {
+            packetplayoutmapchunk_chunkmap.a = new byte[length];
+        }
+        // Migot end
         j = 0;
         Iterator iterator = arraylist.iterator();
 
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
index 10c0e34..8239062 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
@@ -3,7 +3,12 @@ package net.minecraft.server;
 import java.io.IOException;
 import java.util.List;
 
-public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut> {
+// Migot start
+import de.minetick.PacketBuilderBuffer;
+import de.minetick.SendBufferPacketBase;
+// Migot end
+
+public class PacketPlayOutMapChunkBulk extends SendBufferPacketBase implements Packet<PacketListenerPlayOut> {
 
     private int[] a;
     private int[] b;
@@ -13,7 +18,14 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
 
     public PacketPlayOutMapChunkBulk() {}
 
+    // Migot start
     public PacketPlayOutMapChunkBulk(List<Chunk> list) {
+        this(null, list);
+    }
+
+    public PacketPlayOutMapChunkBulk(PacketBuilderBuffer pbb, List<Chunk> list) {
+        super(pbb);
+    // Migot end
         int i = list.size();
 
         this.a = new int[i];
@@ -23,7 +35,7 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
 
         for (int j = 0; j < i; ++j) {
             Chunk chunk = (Chunk) list.get(j);
-            PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = PacketPlayOutMapChunk.a(chunk, true, this.d, '\uffff');
+            PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = PacketPlayOutMapChunk.a(this.pbb, chunk, true, this.d, '\uffff'); // Migot
 
             this.a[j] = chunk.locX;
             this.b[j] = chunk.locZ;
@@ -74,6 +86,11 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
             packetdataserializer.writeBytes(this.c[i].a);
         }
 
+        // Migot start
+        if(this.decreaseAndGetUseCount() == 0) {
+            this.freeSendBuffer(this.c);
+        }
+        // Migot end
     }
 
     public void a(PacketListenerPlayOut packetlistenerplayout) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index abb24c8..171472c 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -15,6 +15,15 @@ import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import java.util.HashMap;
 // CraftBukkit end
 
+// Migot start
+import de.minetick.ChunkGenerationPolicy;
+import de.minetick.Migot;
+import de.minetick.PlayerChunkBuffer;
+import de.minetick.PlayerChunkManager;
+import de.minetick.PlayerChunkSendQueue;
+import org.bukkit.craftbukkit.util.LongHash;
+// Migot end
+
 public class PlayerChunkMap {
 
     private static final Logger a = LogManager.getLogger();
@@ -28,9 +37,30 @@ public class PlayerChunkMap {
     private final int[][] i = new int[][] { { 1, 0}, { 0, 1}, { -1, 0}, { 0, -1}};
     private boolean wasNotEmpty; // CraftBukkit - add field
 
+    // Migot start
+    private PlayerChunkManager playerChunkManager;
+
+    public void skipChunkGeneration(boolean skip) {
+        this.playerChunkManager.skipChunkGeneration(skip);
+    }
+
+    public int updatePlayers(ChunkGenerationPolicy chunkGenerationPolicy) {
+        return this.playerChunkManager.updatePlayers(chunkGenerationPolicy);
+    }
+
+    public int getViewDistance() {
+        return this.g;
+    }
+
+    public PlayerChunkManager getPlayerChunkManager() {
+        return this.playerChunkManager;
+    }
+    // Migot end
+
     public PlayerChunkMap(WorldServer worldserver, int viewDistance /* Spigot */) {
         this.world = worldserver;
         this.a(viewDistance); // Spigot
+        this.playerChunkManager = new PlayerChunkManager(this.world, this); // Migot
     }
 
     public WorldServer a() {
@@ -85,7 +115,7 @@ public class PlayerChunkMap {
         return this.d.getEntry(k) != null;
     }
 
-    private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    public PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) { // Migot - public
         long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
         PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.getEntry(k);
 
@@ -120,6 +150,7 @@ public class PlayerChunkMap {
     }
 
     public void addPlayer(EntityPlayer entityplayer) {
+        /* Migot - see the rewrite below
         int i = (int) entityplayer.locX >> 4;
         int j = (int) entityplayer.locZ >> 4;
 
@@ -143,8 +174,48 @@ public class PlayerChunkMap {
 
         this.managedPlayers.add(entityplayer);
         this.b(entityplayer);
+        */
+        // Migot start - chunks are queued for loading except the one the player is in
+        int i = MathHelper.floor(entityplayer.locX) >> 4;
+        int j = MathHelper.floor(entityplayer.locZ) >> 4;
+
+        entityplayer.d = entityplayer.locX;
+        entityplayer.e = entityplayer.locZ;
+
+        PlayerChunkBuffer buffer = this.playerChunkManager.addPlayer(entityplayer);
+        PlayerChunkSendQueue sendQueue = buffer.getPlayerChunkSendQueue();
+        entityplayer.setPlayerChunkSendQueue(sendQueue);
+
+        List<ChunkCoordIntPair> chunkList = new ArrayList<ChunkCoordIntPair>(450);
+        boolean areaExists = this.playerChunkManager.doAllCornersOfPlayerAreaExist(i, j, this.g);
+        int viewDistance = this.getViewDistance();
+        for (int k = i - viewDistance; k <= i + viewDistance; ++k) {
+            for (int l = j - viewDistance; l <= j + viewDistance; ++l) {
+                ChunkCoordIntPair ccip = new ChunkCoordIntPair(k, l);
+                sendQueue.addToServer(k, l);
+                if(areaExists) {
+                    if(this.a(k, l, i, j, 0)) {
+                        chunkList.add(ccip);
+                    } else {
+                        buffer.addHighPriorityChunk(ccip);
+                    }
+                } else {
+                    buffer.addLowPriorityChunk(ccip);
+                }
+            }
+        }
+
+        for (ChunkCoordIntPair pair : chunkList) {
+            PlayerChunk c = this.a(pair.x, pair.z, true);
+            c.a(entityplayer);
+            sendQueue.queueForSend(c, entityplayer);
+        }
+
+        this.managedPlayers.add(entityplayer);
+        // Migot end
     }
 
+    /* Migot - not required anymore
     public void b(EntityPlayer entityplayer) {
         ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
         int i = 0;
@@ -189,8 +260,10 @@ public class PlayerChunkMap {
         }
 
     }
+    */
 
     public void removePlayer(EntityPlayer entityplayer) {
+        /* Migot - see rewrite below
         int i = (int) entityplayer.d >> 4;
         int j = (int) entityplayer.e >> 4;
 
@@ -203,6 +276,22 @@ public class PlayerChunkMap {
                 }
             }
         }
+        */
+        // Migot start
+        PlayerChunkSendQueue pcsq = entityplayer.chunkQueue;
+        if(pcsq != null) {
+            java.util.Collection<Long> enlistedChunks = pcsq.getEnlistedChunkHashes();
+            for(Long hash: enlistedChunks) {
+                PlayerChunk playerchunk = this.a(LongHash.lsw(hash), LongHash.msw(hash), false);
+                if(playerchunk != null) {
+                    playerchunk.b(entityplayer);
+                }
+            }
+            pcsq.clear();
+        }
+        entityplayer.setPlayerChunkSendQueue(null);
+        this.playerChunkManager.removePlayer(entityplayer);
+        // Migot end
 
         this.managedPlayers.remove(entityplayer);
     }
@@ -215,6 +304,7 @@ public class PlayerChunkMap {
     }
 
     public void movePlayer(EntityPlayer entityplayer) {
+        /* Migot - The PlayerChunkManager is going to take care of loading player chunks
         int i = (int) entityplayer.locX >> 4;
         int j = (int) entityplayer.locZ >> 4;
         double d0 = entityplayer.d - entityplayer.locX;
@@ -262,12 +352,45 @@ public class PlayerChunkMap {
                 // CraftBukkit end
             }
         }
+        */
+        // Migot start
+        double distX = entityplayer.d - entityplayer.locX;
+        double distZ = entityplayer.e - entityplayer.locZ;
+        if((distX * distX + distZ * distZ) >= 128.0D) {
+            int newPosX = MathHelper.floor(entityplayer.locX) >> 4;
+            int newPosZ = MathHelper.floor(entityplayer.locZ) >> 4;
+            int oldPosX = MathHelper.floor(entityplayer.d) >> 4;
+            int oldPosZ = MathHelper.floor(entityplayer.e) >> 4;
+            int diffX = newPosX - oldPosX;
+            int diffZ = newPosZ - oldPosZ;
+            if (diffX != 0 || diffZ != 0) {
+                PlayerChunkBuffer buffer = this.playerChunkManager.getChunkBuffer(entityplayer);
+                if(buffer != null) {
+                    buffer.playerMoved(newPosX, newPosZ);
+                    entityplayer.d = entityplayer.locX;
+                    entityplayer.e = entityplayer.locZ;
+                }
+            }
+        }
+        // Migot end
     }
 
     public boolean a(EntityPlayer entityplayer, int i, int j) {
         PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = this.a(i, j, false);
 
-        return playerchunkmap_playerchunk != null && playerchunkmap_playerchunk.b.contains(entityplayer) && !entityplayer.chunkCoordIntPairQueue.contains(playerchunkmap_playerchunk.location);
+        //return playerchunkmap_playerchunk != null && playerchunkmap_playerchunk.b.contains(entityplayer) && !entityplayer.chunkCoordIntPairQueue.contains(playerchunkmap_playerchunk.location);
+        // Migot start
+        if(playerchunkmap_playerchunk != null) {
+            ChunkCoordIntPair ccip = playerchunkmap_playerchunk.location;
+            boolean chunkIsSent = false;
+            PlayerChunkSendQueue sq = entityplayer.chunkQueue;
+            if(sq != null) {
+                chunkIsSent = sq.isChunkSent(ccip);
+            }
+            return chunkIsSent && playerchunkmap_playerchunk.b.contains(entityplayer);
+        }
+        return false;
+        // Migot end
     }
 
     public void a(int i) {
@@ -313,7 +436,7 @@ public class PlayerChunkMap {
         return i * 16 - 16;
     }
 
-    class PlayerChunk {
+    public class PlayerChunk { // Migot - public
 
         private final List<EntityPlayer> b = Lists.newArrayList();
         private final ChunkCoordIntPair location;
@@ -332,9 +455,27 @@ public class PlayerChunkMap {
         };
         // CraftBukkit end
 
+        // Migot start
+        private boolean newChunk = false;
+        public boolean getAndResetIsNew() {
+            boolean out = this.newChunk;
+            this.newChunk = false;
+            return out;
+        }
+
+        public ChunkCoordIntPair getLocation() {
+            return this.location;
+        }
+        // Migot end
+
         public PlayerChunk(int i, int j) {
             this.location = new ChunkCoordIntPair(i, j);
-            PlayerChunkMap.this.a().chunkProviderServer.getChunkAt(i, j, loadedRunnable); // CraftBukkit
+            // Migot start
+            Chunk chunk = PlayerChunkMap.this.a().chunkProviderServer.getChunkAt(i, j, loadedRunnable); // CraftBukkit
+            if(chunk != null && !chunk.isEmpty()) {
+                this.newChunk = chunk.getAndResetIsNew();
+            }
+            // Migot end
         }
 
         public void a(final EntityPlayer entityplayer) {  // CraftBukkit - added final to argument
@@ -350,11 +491,11 @@ public class PlayerChunkMap {
                 Runnable playerRunnable;
                 if (this.loaded) {
                     playerRunnable = null;
-                    entityplayer.chunkCoordIntPairQueue.add(this.location);
+                    //entityplayer.chunkCoordIntPairQueue.add(this.location); // Migot
                 } else {
                     playerRunnable = new Runnable() {
                         public void run() {
-                            entityplayer.chunkCoordIntPairQueue.add(PlayerChunk.this.location);
+                            //entityplayer.chunkCoordIntPairQueue.add(PlayerChunk.this.location); // Migot
                         }
                     };
                     PlayerChunkMap.this.a().chunkProviderServer.getChunkAt(this.location.x, this.location.z, playerRunnable);
@@ -386,12 +527,12 @@ public class PlayerChunkMap {
                 Chunk chunk = PlayerChunkMap.this.world.getChunkAt(this.location.x, this.location.z);
 
                 if (chunk.isReady()) {
-                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(chunk, true, 0));
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(Migot.getPacketBuilderBuffer(), chunk, true, 0)); // Migot
                 }
 
                 this.players.remove(entityplayer); // CraftBukkit
                 this.b.remove(entityplayer);
-                entityplayer.chunkCoordIntPairQueue.remove(this.location);
+                //entityplayer.chunkCoordIntPairQueue.remove(this.location); // Migot
                 if (this.b.isEmpty()) {
                     long i = (long) this.location.x + 2147483647L | (long) this.location.z + 2147483647L << 32;
 
@@ -441,9 +582,19 @@ public class PlayerChunkMap {
             for (int i = 0; i < this.b.size(); ++i) {
                 EntityPlayer entityplayer = (EntityPlayer) this.b.get(i);
 
+                /* Migot
                 if (!entityplayer.chunkCoordIntPairQueue.contains(this.location)) {
                     entityplayer.playerConnection.sendPacket(packet);
                 }
+                */
+                // Migot start
+                PlayerChunkSendQueue sq = entityplayer.chunkQueue;
+                if(sq != null) {
+                    if(!sq.isAboutToSend(this.location)) {
+                        entityplayer.playerConnection.sendPacket(packet);
+                    }
+                }
+                // Migot end
             }
 
         }
@@ -470,7 +621,11 @@ public class PlayerChunkMap {
                     if (this.dirtyCount == 64) {
                         i = this.location.x * 16;
                         j = this.location.z * 16;
-                        this.a((Packet) (new PacketPlayOutMapChunk(PlayerChunkMap.this.world.getChunkAt(this.location.x, this.location.z), false, this.f)));
+                        // Migot start
+                        PacketPlayOutMapChunk packet = new PacketPlayOutMapChunk(Migot.getPacketBuilderBuffer(), PlayerChunkMap.this.world.getChunkAt(this.location.x, this.location.z), false, this.f);
+                        packet.setUseCount(this.b.size());
+                        this.a((Packet) packet);
+                        // Migot end
 
                         for (k = 0; k < 16; ++k) {
                             if ((this.f & 1 << k) != 0) {
@@ -515,6 +670,7 @@ public class PlayerChunkMap {
         }
     }
 
+    /* Migot - replaced by MinetickChunkCoordComparator
     // CraftBukkit start - Sorter to load nearby chunks first
     private static class ChunkCoordComparator implements java.util.Comparator<ChunkCoordIntPair> {
         private int x;
@@ -557,4 +713,5 @@ public class PlayerChunkMap {
         }
     }
     // CraftBukkit end
+    */
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index bc1c3c6..0f1e9d7 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -29,6 +29,8 @@ import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 // CraftBukkit end
 
+import de.minetick.ChunkGenerationPolicy; // Migot
+
 public class WorldServer extends World implements IAsyncTaskHandler {
 
     private static final Logger a = LogManager.getLogger();
@@ -53,6 +55,22 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     // Migot start
     public void cancelHeavyCalculations(boolean cancel) {
         this.cancelHeavyCalculations = cancel;
+        this.manager.skipChunkGeneration(cancel);
+    }
+
+    private ChunkGenerationPolicy chunkGenerationPolicy = new ChunkGenerationPolicy();
+
+    public boolean chunkExists(int x, int z) {
+        return this.chunkProviderServer.doesChunkExist(x, z);
+    }
+
+    public int loadAndGenerateChunks() {
+        if(this.players.size() > 0) {
+            this.chunkGenerationPolicy.newTick();
+            return this.manager.updatePlayers(this.chunkGenerationPolicy);
+        } else {
+            return 0;
+        }
     }
     // Migot end
 
diff --git a/src/main/resources/configurations/migot.yml b/src/main/resources/configurations/migot.yml
index 5e406f0..4ff0cd1 100644
--- a/src/main/resources/configurations/migot.yml
+++ b/src/main/resources/configurations/migot.yml
@@ -24,3 +24,14 @@ pathsearches:
     - SQUID
     - WITCH
     - ZOMBIE
+chunkloading:
+    packetChunkRates:
+        HIGHEST: 5
+        HIGH: 4
+        MODERATE: 3
+        LOW: 3
+    maxChunkGenerationRates:
+        DEFAULT: 1.0
+        FLAT: 2.0
+        LARGEBIOMES: 1.0
+        AMPLIFIED: 0.5
-- 
1.8.3.msysgit.0

