From e71f39c8da4f2cf891345fd2025b3d3dd8ca75d3 Mon Sep 17 00:00:00 2001
From: Poweruser <poweruser.rs@hotmail.com>
Date: Mon, 31 Aug 2015 21:39:11 +0200
Subject: [PATCH] Client Controlled View Distance


diff --git a/src/main/java/de/minetick/Migot.java b/src/main/java/de/minetick/Migot.java
index 3cf1645..f5cecae 100644
--- a/src/main/java/de/minetick/Migot.java
+++ b/src/main/java/de/minetick/Migot.java
@@ -99,6 +99,10 @@ public class Migot {
                 }
             } catch(InterruptedException e) {}
         }
+
+        if(getConfig() != null) {
+            getConfig().saveViewDistances();
+        }
     }
 
     public void checkTickTime(long tickTime) {
diff --git a/src/main/java/de/minetick/MigotConfig.java b/src/main/java/de/minetick/MigotConfig.java
index 439924c..681486e 100644
--- a/src/main/java/de/minetick/MigotConfig.java
+++ b/src/main/java/de/minetick/MigotConfig.java
@@ -9,6 +9,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.UUID;
 
 import net.minecraft.server.EntityInsentient;
 
@@ -33,6 +34,8 @@ public class MigotConfig {
     private File configFile;
     private FileConfiguration configuration;
     private HashSet<EntityType> entitiesWithOffloadedPathSearches = new HashSet<EntityType>();
+    private File viewdistanceConfigFile;
+    private FileConfiguration viewdistanceConfig;
 
     public MigotConfig(File configFile) throws IOException, InvalidConfigurationException {
         this.configFile = configFile;
@@ -45,6 +48,17 @@ public class MigotConfig {
         }
 
         this.loadConfigContent();
+
+        this.viewdistanceConfigFile = new File("migot_viewdistance.yml");
+        try {
+            if(!this.viewdistanceConfigFile.exists()) {
+                this.viewdistanceConfigFile.createNewFile();
+            }
+            this.viewdistanceConfig = YamlConfiguration.loadConfiguration(this.viewdistanceConfigFile);
+        } catch (IOException e) {
+            logger.error("[Migot] Could not load the stored player view distances from migot_viewdistance.yml: " + e.toString());
+            e.printStackTrace();
+        }
     }
 
     public FileConfiguration[] reload() throws IOException, InvalidConfigurationException {
@@ -144,4 +158,38 @@ public class MigotConfig {
         }
         return rateMap;
     }
+
+    public int getMinimumViewDistance() {
+        return 3;
+    }
+
+    public void setPlayerViewDistance(UUID playerId, int viewDistance) {
+        if(this.viewdistanceConfig != null && this.isClientControlledViewDistanceEnabled()) {
+            this.viewdistanceConfig.set(playerId.toString(), (viewDistance < this.getMinimumViewDistance()) ? null : Math.max(viewDistance, this.getMinimumViewDistance()));
+        }
+    }
+
+    public int getPlayerViewDistance(UUID playerId, int defaultVD) {
+        if(this.viewdistanceConfig != null && this.isClientControlledViewDistanceEnabled()) {
+            int playerVD = this.viewdistanceConfig.getInt(playerId.toString(), defaultVD);
+            playerVD = Math.max(playerVD, this.getMinimumViewDistance());
+            return Math.min(playerVD, defaultVD);
+        }
+        return defaultVD;
+    }
+
+    protected void saveViewDistances() {
+        try {
+            if(this.viewdistanceConfig != null && this.isClientControlledViewDistanceEnabled()) {
+                this.viewdistanceConfig.save(this.viewdistanceConfigFile);
+            }
+        } catch (IOException e){
+            logger.error("Exception while saving view distance settings");
+            e.printStackTrace();
+        }
+    }
+
+    public boolean isClientControlledViewDistanceEnabled() {
+        return configuration.getBoolean("chunkloading.clientControlledViewDistance", true);
+    }
 }
diff --git a/src/main/java/de/minetick/PlayerChunkBuffer.java b/src/main/java/de/minetick/PlayerChunkBuffer.java
index cf5191c..09c072e 100644
--- a/src/main/java/de/minetick/PlayerChunkBuffer.java
+++ b/src/main/java/de/minetick/PlayerChunkBuffer.java
@@ -28,6 +28,7 @@ public class PlayerChunkBuffer {
     private int[] playerRegionCenter;
     private int[] lastMovement;
     private ArrayDeque<PlayerMovement> movement;
+    private int oldViewDistance;
 
     public PlayerChunkBuffer(PlayerChunkManager playerChunkManager, EntityPlayer ent) {
         this.playerChunkManager = playerChunkManager;
@@ -39,6 +40,9 @@ public class PlayerChunkBuffer {
         this.playerRegionCenter = new int[] { MathHelper.floor(ent.locX) >> 4, MathHelper.floor(ent.locZ) >> 4 };
         this.lastMovement = new int[] { 0, 0 };
         this.movement = new ArrayDeque<PlayerMovement>();
+        int savedVD = Migot.getConfig().getPlayerViewDistance(ent.getUniqueID(), this.playerChunkManager.getPlayerChunkMap().getViewDistance());
+        this.oldViewDistance = savedVD;
+        ent.setViewDistance(savedVD);
     }
 
     public PlayerChunkSendQueue getPlayerChunkSendQueue() {
@@ -63,13 +67,14 @@ public class PlayerChunkBuffer {
             if(diffX == 0 && diffZ == 0) {
                 return this.comp;
             }
-            int radius = pcm.getViewDistance();
+            int currentViewDistance = entityplayer.getViewDistance();
+            int radius = Math.max(this.oldViewDistance, currentViewDistance);
             int added = 0, removed = 0;
             boolean areaExists = this.playerChunkManager.doAllCornersOfPlayerAreaExist(newCenterX, newCenterZ, radius);
             for (int pointerX = newCenterX - radius; pointerX <= newCenterX + radius; pointerX++) {
                 for (int pointerZ = newCenterZ - radius; pointerZ <= newCenterZ + radius; pointerZ++) {
                     ChunkCoordIntPair ccip;
-                    if(!PlayerChunkManager.isWithinRadius(pointerX, pointerZ, oldCenterX, oldCenterZ, radius)) {
+                    if(!PlayerChunkManager.isWithinRadius(pointerX, pointerZ, oldCenterX, oldCenterZ, this.oldViewDistance)) {
                         ccip = new ChunkCoordIntPair(pointerX, pointerZ);
                         if(!this.sendQueue.alreadyLoaded(ccip) && !this.sendQueue.isOnServer(ccip)) {
                             added++;
@@ -82,7 +87,7 @@ public class PlayerChunkBuffer {
                         }
                     }
 
-                    if(!PlayerChunkManager.isWithinRadius(pointerX - diffX, pointerZ - diffZ, newCenterX, newCenterZ, radius)) {
+                    if(!PlayerChunkManager.isWithinRadius(pointerX - diffX, pointerZ - diffZ, newCenterX, newCenterZ, currentViewDistance)) {
                         removed++;
                         ccip = new ChunkCoordIntPair(pointerX - diffX, pointerZ - diffZ);
                         this.sendQueue.removeFromServer(ccip.x, ccip.z);
@@ -95,6 +100,7 @@ public class PlayerChunkBuffer {
                     }
                 }
             }
+            this.oldViewDistance = currentViewDistance;
         }
         return this.comp;
     }
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 73b6326..63a7dbd 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -25,6 +25,7 @@ import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 // CraftBukkit end
 
 // Migot start
+import de.minetick.Migot;
 import de.minetick.PlayerChunkSendQueue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 // Migot end
@@ -86,6 +87,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     // Migot start
     public PlayerChunkSendQueue chunkQueue;
     private ConcurrentLinkedQueue<Chunk> chunksForTracking = new ConcurrentLinkedQueue<Chunk>();
+    private int clientViewDistance;
 
     public void setPlayerChunkSendQueue(PlayerChunkSendQueue pcsq) {
         if(this.chunkQueue != null) {
@@ -97,6 +99,20 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public void queueChunksForTracking(List<Chunk> list) {
         this.chunksForTracking.addAll(list);
     }
+
+    public void setViewDistance(int distance) {
+        int serverVD = ((WorldServer)this.world).getPlayerChunkMap().getViewDistance();
+        if(Migot.getConfig().isClientControlledViewDistanceEnabled()) {
+            this.clientViewDistance = Math.min(Math.max(distance, Migot.getConfig().getMinimumViewDistance()), serverVD);
+            Migot.getConfig().setPlayerViewDistance(this.getUniqueID(), (this.clientViewDistance < serverVD) ? this.clientViewDistance : -1);
+        } else {
+            this.clientViewDistance = serverVD;
+        }
+    }
+
+    public int getViewDistance() {
+        return this.clientViewDistance;
+    }
     // Migot end
 
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
@@ -134,6 +150,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         // this.canPickUpLoot = true; TODO
         this.maxHealthCache = this.getMaxHealth();
         // CraftBukkit end
+
+        this.clientViewDistance = Migot.getConfig().getPlayerViewDistance(this.getUniqueID(), worldserver.getPlayerChunkMap().getViewDistance()); // Migot
     }
 
     public void a(NBTTagCompound nbttagcompound) {
@@ -1032,6 +1050,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     public void a(PacketPlayInSettings packetplayinsettings) {
         this.locale = packetplayinsettings.a();
+        this.setViewDistance(packetplayinsettings.getClientViewDistance()); // Migot
         this.bR = packetplayinsettings.c();
         this.bS = packetplayinsettings.d();
         this.getDataWatcher().watch(10, Byte.valueOf((byte) packetplayinsettings.e()));
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index f0149bf..35f4296 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -416,7 +416,11 @@ public class EntityTrackerEntry {
         double d1 = entityplayer.locZ - this.tracker.locZ;
         // CraftBukkit end
 
-        return d0 >= (double) (-this.b) && d0 <= (double) this.b && d1 >= (double) (-this.b) && d1 <= (double) this.b && this.tracker.a(entityplayer);
+        // Migot start
+        //return d0 >= (double) (-this.b) && d0 <= (double) this.b && d1 >= (double) (-this.b) && d1 <= (double) this.b && this.tracker.a(entityplayer);
+        double range = Math.min((double) this.b, ((double) (entityplayer.getViewDistance() - 1)) * 16.0D);
+        return d0 >= -range && d0 <= range && d1 >= -range && d1 <= range && this.tracker.a(entityplayer);
+        // Migot end
     }
 
     private boolean e(EntityPlayer entityplayer) {
diff --git a/src/main/java/net/minecraft/server/PacketPlayInSettings.java b/src/main/java/net/minecraft/server/PacketPlayInSettings.java
index 8b79cd0..53cc637 100644
--- a/src/main/java/net/minecraft/server/PacketPlayInSettings.java
+++ b/src/main/java/net/minecraft/server/PacketPlayInSettings.java
@@ -53,4 +53,10 @@ public class PacketPlayInSettings implements Packet<PacketListenerPlayIn> {
         this.a((PacketListenerPlayIn) packetlistener);
     }
     */
+
+    // MinetickMod start
+    public int getClientViewDistance() {
+        return this.b;
+    }
+    // MinetickMod end
 }
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 1a0e237..9e1af56 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -187,7 +187,7 @@ public class PlayerChunkMap {
 
         List<ChunkCoordIntPair> chunkList = new ArrayList<ChunkCoordIntPair>(450);
         boolean areaExists = this.playerChunkManager.doAllCornersOfPlayerAreaExist(i, j, this.g);
-        int viewDistance = this.getViewDistance();
+        int viewDistance = entityplayer.getViewDistance();
         for (int k = i - viewDistance; k <= i + viewDistance; ++k) {
             for (int l = j - viewDistance; l <= j + viewDistance; ++l) {
                 ChunkCoordIntPair ccip = new ChunkCoordIntPair(k, l);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index bf87969..ff7ba3b 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -2219,11 +2219,13 @@ public abstract class World implements IBlockAccess {
             int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
             chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
 
+            int playerRange = Math.min(randRange, ((EntityPlayer) entityhuman).getViewDistance()); // Migot
+
             // Check and see if we update the chunks surrounding the player this tick
             for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
             {
-                int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
-                int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( playerRange ); // Migot
+                int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( playerRange ); // Migot
                 long hash = chunkToKey( dx + j, dz + k );
                 if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
                 {
diff --git a/src/main/resources/configurations/migot.yml b/src/main/resources/configurations/migot.yml
index 4ff0cd1..7a6741c 100644
--- a/src/main/resources/configurations/migot.yml
+++ b/src/main/resources/configurations/migot.yml
@@ -35,3 +35,4 @@ chunkloading:
         FLAT: 2.0
         LARGEBIOMES: 1.0
         AMPLIFIED: 0.5
+    clientControlledViewDistance: true
-- 
1.8.3.msysgit.0

